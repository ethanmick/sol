# Space Game v001 Plan

## Overview

Slim MVP around a server-tick core with in-memory authority + periodic durable snapshots. Real-time multiplayer space trading game with minimal feature set.

## Core Loop (Slim MVP)

- Undock → fly → arrive/dock
- Buy/sell one commodity
- Multiplayer, real time
- (No quests yet)

## Architecture

### Project Structure

- `apps/server/` - Hono game server with tick-based simulation
- `apps/www/` - React client frontend
- `packages/game/` - Shared TypeScript schemas and types (Zod-based)
- Communication: Hono RPC for type-safe client-server communication

### Big Structural Changes

1. Authoritative tick simulation (server computes everything each tick)
2. All live state in memory; background snapshots to durable storage every few minutes
3. Hono RPC for type-safe client-server communication with shared schemas

## Data Model (1-3 attributes per entity)

### Player

- `id` - unique identifier
- `username` - display name

### Corporation

- `id` - unique identifier
- `player_id` - owning player reference
- `credits` - currency balance

### Ship

- `id` - unique identifier
- `player_id` - owning player reference
- `corp_id` - corporation reference
- `mode` - `Docked | Flight`
- `pos` - `{x, y}` coordinates
- `cargo_units` - current cargo amount

_Note: No persisted velocity/destination - computed at runtime. Ephemeral `dest_node_id` in memory only._

### Node (planet/station)

- `id` - unique identifier
- `name` - display name for the game
- `pos` - `{x, y}` coordinates (computed from orbit function)
- `price` - commodity price

### Global Constants (hardcoded config)

- `MAX_CAPACITY = 20`
- `SHIP_SPEED = 500` (units/sec)
- `DOCK_RADIUS = 2000` (units)
- `TICK_RATE = 5` Hz
- `PRICE_TICK_INTERVAL = 30` seconds
- `SYSTEM_TIME_ORIGIN` - epoch for orbits

## World Simulation

### Celestial Motion

- Nodes follow circular orbits: `pos(t) = center + R * [cos(ωt+φ), sin(ωt+φ)]`
- Stationary hubs: `R = 0`
- Motion computed deterministically from server time

### Ship Movement

- **Docked**: `pos = node.pos(t)` each tick
- **Flight**: Move straight toward `dest_node.pos(t)`
  - `dir = normalize(dest_pos(t) - ship.pos)`
  - `ship.pos += SHIP_SPEED * dir * dt`
  - Routes naturally bend as planets move (implicit intercept mechanics)

## Tick Pipeline (5 Hz Authoritative Loop)

1. **Advance Time**: `now = monotonic_time()`

2. **Update Nodes**:

   - Compute `pos = orbit(now)` for each node
   - Every 30s: bounded random walk on prices

3. **Integrate Ships**:

   - Docked: `ship.pos = node.pos`
   - Flight: Move toward `dest_node.pos(now)`

4. **Arrival Checks**:

   - If `distance(ship.pos, dest.pos) <= DOCK_RADIUS`:
     - Set `mode = Docked(dest_id)`
     - Snap `pos = dest.pos`
     - Emit `ShipArrived`

5. **Encounter Phase** (mid-flight):

_NOT DOING FOR NOW_

   <!-- - Random encounters for Flight ships (low λ)
   - MVP: "Pirate toll" - pay credits or get delayed
   - Purely ephemeral state (no new persisted fields) -->

6. **Event Dispatch**:

   - Prepare state diffs for client polling

7. **Housekeeping**:
   - Cull idle connections, bounded caches

## Client-Server Communication

### Hono RPC Architecture

Client uses Hono RPC client for type-safe API calls, polling server every 1 second.

#### Shared Types (`packages/game/`)

```typescript
// schemas.ts - Zod schemas for runtime validation and TypeScript types
import { z } from 'zod'

export const PlayerSchema = z.object({
  id: z.string(),
  username: z.string(),
})

export const CorporationSchema = z.object({
  id: z.string(),
  player_id: z.string(),
  credits: z.number(),
})

export const ShipSchema = z.object({
  id: z.string(),
  player_id: z.string(),
  corp_id: z.string(),
  mode: z.enum(['Docked', 'Flight']),
  pos: z.object({ x: z.number(), y: z.number() }),
  cargo_units: z.number(),
})

export const NodeSchema = z.object({
  id: z.string(),
  name: z.string(),
  pos: z.object({ x: z.number(), y: z.number() }),
  price: z.number(),
})

export const GameStateSchema = z.object({
  server_time: z.number(),
  tick_rate: z.number(),
  players: z.array(PlayerSchema),
  corporations: z.array(CorporationSchema),
  ships: z.array(ShipSchema),
  nodes: z.array(NodeSchema),
})

// TypeScript types derived from schemas
export type Player = z.infer<typeof PlayerSchema>
export type Corporation = z.infer<typeof CorporationSchema>
export type Ship = z.infer<typeof ShipSchema>
export type Node = z.infer<typeof NodeSchema>
export type GameState = z.infer<typeof GameStateSchema>
```

#### Server Routes (`apps/server/`)

```typescript
// app.ts - Hono server with typed routes
import { Hono } from 'hono'
import { zValidator } from '@hono/zod-validator'
import { GameStateSchema } from '@game/schemas'

const app = new Hono()
  .get('/api/game/state', (c) => {
    const gameState = getGameState()
    return c.json(gameState) // Type-safe response
  })
  .post(
    '/api/ship/depart',
    zValidator(
      'json',
      z.object({
        ship_id: z.string(),
        dest_node_id: z.string(),
      })
    ),
    (c) => {
      const { ship_id, dest_node_id } = c.req.valid('json')
      const result = departShip(ship_id, dest_node_id)
      return c.json({ success: true })
    }
  )
  .post(
    '/api/ship/buy',
    zValidator(
      'json',
      z.object({
        ship_id: z.string(),
        units: z.number(),
      })
    ),
    (c) => {
      const { ship_id, units } = c.req.valid('json')
      const result = buyGoods(ship_id, units)
      return c.json({ success: true })
    }
  )
  .post(
    '/api/ship/sell',
    zValidator(
      'json',
      z.object({
        ship_id: z.string(),
        units: z.number(),
      })
    ),
    (c) => {
      const { ship_id, units } = c.req.valid('json')
      const result = sellGoods(ship_id, units)
      return c.json({ success: true })
    }
  )

export type AppType = typeof app
export default app
```

#### Client Usage (`apps/www/`)

```typescript
// services/api.ts - Type-safe Hono RPC client
import { hc } from 'hono/client'
import type { AppType } from '@server/app'

const client = hc<AppType>('http://localhost:3000')

export async function getGameState() {
  const res = await client.api.game.state.$get()
  if (res.ok) {
    return await res.json() // Fully typed GameState
  }
  throw new Error('Failed to fetch game state')
}

export async function departShip(ship_id: string, dest_node_id: string) {
  const res = await client.api.ship.depart.$post({
    json: { ship_id, dest_node_id },
  })
  return await res.json()
}

// services/gameLoop.ts - Polling with full type safety
export class GameLoop {
  async poll() {
    const gameState = await getGameState()
    // gameState.ships[0].pos.x - all fully typed!
    this.updateUI(gameState)
  }
}
```

## Gameplay Actions (Tick-Aware)

### Command Validation

- **DEPART**: Ship must be Docked
- **BUY**: Must be Docked, have capacity and credits
- **SELL**: Must be Docked, have cargo

All commands executed in simulation thread, idempotent with `op_id`.

## Persistence Model

### Live Authority (In-Memory)

```typescript
// Server State - Uses shared types from packages/game
import type { Player, Corporation, Ship, Node } from '@game/schemas'

{
  players: Map<string, Player>,
  corps: Map<string, Corporation>,
  ships: Map<string, Ship>,
  nodes: Map<string, Omit<Node, 'pos'> & { pos?: {x: number, y: number} }>, // pos computed from orbit functions
  ephemeral: {
    encounters_in_flight: Map<string, any>,
    pending_orders: Queue<any>,
    dest_assignments: Map<string, string> // ship_id -> node_id
  }
}
```

### Durability (Background)

- **Snapshots**: Every 2-5 minutes to JSON file/S3
- **Write-Ahead Log**: Compact events (TradeExecuted, ShipDeparted, etc.)
- **Recovery**: Load latest snapshot + replay WAL entries

## Testing Defaults

- **TICK_RATE**: 5 Hz server, client interpolates to 30-60 FPS
- **WORLD**: 5 starter nodes (2 orbital, 1 stationary hub)
- **PRICING**: 30s intervals, ±1 bounded random walk
- **ENCOUNTERS**: Low probability pirate tolls

## Multiplayer Interactions

- Shared node prices (arbitrage pressure)
- Visible arrivals/departures at nodes
- Future: In-flight interceptions via position awareness
